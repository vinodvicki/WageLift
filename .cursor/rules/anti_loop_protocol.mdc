# Anti-Loop Protocol

This protocol prevents getting stuck in repetitive loops when solving problems.

## üö® MANDATORY PROCESS - VERIFY ‚Üí PLAN ‚Üí EXECUTE ‚Üí CONFIRM

### 1. STATE VERIFICATION (Always First)
**BEFORE any action, ALWAYS:**
- ‚úÖ Test current state with simple commands
- ‚úÖ Document what IS working vs what ISN'T working
- ‚úÖ Set clear success criteria (what does "fixed" look like?)
- ‚úÖ Identify the EXACT problem, not assumptions

**Example:**
```bash
# Good: Verify current state first
curl -I http://localhost:8000  # Test if server responds
curl -I http://localhost:3000  # Test frontend

# Bad: Assume something is broken and start fixing
```

### 2. SINGLE APPROACH RULE
**Choose ONE solution path and stick to it:**
- ‚úÖ Pick the simplest solution first
- ‚úÖ Complete it fully before trying alternatives  
- ‚úÖ Maximum 3 attempts per approach
- ‚úÖ If approach fails 3 times, escalate to next level

**Escalation Ladder:**
1. **Level 1:** Simple fixes (restart, basic config)
2. **Level 2:** Medium complexity (dependency changes, environment)  
3. **Level 3:** Complex solutions (Docker, complete rewrites)

### 3. FAILURE LEARNING SYSTEM
**Track and learn from failures:**
- ‚úÖ Log what failed and the exact error message
- ‚úÖ Never repeat the EXACT same command that failed
- ‚úÖ If same error appears twice, escalate approach
- ‚úÖ Document why each attempt failed

**Example Failure Log:**
```
Attempt 1: pip install -r requirements.txt
Error: pydantic-core build failed (Python 3.13 incompatibility)
Lesson: Don't retry full requirements.txt

Attempt 2: pip install minimal deps
Result: Success
```

### 4. TIME MANAGEMENT LIMITS
**Strict timeouts to prevent endless loops:**
- ‚úÖ 5-minute maximum per approach
- ‚úÖ 15-minute maximum per problem
- ‚úÖ 3 consecutive failures = STOP and reassess
- ‚úÖ After timeout, document findings and ask for guidance

### 5. LOOP DETECTION TRIGGERS
**Stop immediately if you notice:**
- Running the same command more than twice
- Getting the same error repeatedly without changing approach
- Spending >10 minutes on same solution
- Making multiple small changes without testing each one

### 6. SUCCESS CONFIRMATION
**Always confirm the fix worked:**
- ‚úÖ Test the original problem is solved
- ‚úÖ Test related functionality still works
- ‚úÖ Document what the successful solution was
- ‚úÖ Note why this approach worked when others failed

## üéØ PRACTICAL EXAMPLE

**Problem:** Backend server not starting

**‚ùå Loop Behavior:**
```bash
pip install package1
pip install package2  
pip install package1 package2
pip install --upgrade package1
# ... endless variations
```

**‚úÖ Anti-Loop Approach:**
```bash
# 1. VERIFY
curl localhost:8000  # Confirm it's actually broken

# 2. PLAN (Choose ONE approach)
# Approach 1: Check dependencies (5 min limit)

# 3. EXECUTE (Max 3 attempts)
# Attempt 1: pip install -r requirements.txt
# Result: Failed - Python 3.13 incompatibility
# Attempt 2: pip install minimal subset
# Result: Failed - same error
# Attempt 3: Create simple version
# Result: Success

# 4. CONFIRM
curl localhost:8000/health  # Verify fix worked
```

## üõ°Ô∏è ENFORCEMENT RULES

- **NEVER** run the same command twice without changing the approach
- **ALWAYS** test current state before making changes
- **STOP** after 3 consecutive failures and reassess
- **DOCUMENT** what worked for future reference
- **ASK** for guidance if hitting time limits

This protocol must be followed for ALL problem-solving tasks to prevent loops and ensure efficient resolution.